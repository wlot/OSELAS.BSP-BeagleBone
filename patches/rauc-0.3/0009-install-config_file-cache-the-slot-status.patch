From f77d5c20097551471b6e3b876a9deb68daaf2e22 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ulrich=20=C3=96lmann?= <u.oelmann@pengutronix.de>
Date: Thu, 31 Aug 2017 12:44:41 +0200
Subject: [PATCH 09/44] install/config_file: cache the slot status
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Instead of mounting the slot, reading its status information from the status
file and unmounting it over and over again, cache the information inside a
component of the slot data structure for subsequent usage.

Signed-off-by: Ulrich Ã–lmann <u.oelmann@pengutronix.de>
---
 include/config_file.h | 28 +++++++++++++++-------------
 src/config_file.c     | 22 ++++++++++++++++------
 src/install.c         |  6 ++----
 3 files changed, 33 insertions(+), 23 deletions(-)

diff --git a/include/config_file.h b/include/config_file.h
index 79b0206..5d50919 100644
--- a/include/config_file.h
+++ b/include/config_file.h
@@ -59,6 +59,11 @@ typedef enum {
 #define R_SLOT_ERROR r_slot_error_quark()
 GQuark r_slot_error_quark(void);
 
+typedef struct {
+	gchar *status;
+	RaucChecksum checksum;
+} RaucSlotStatus;
+
 typedef struct _RaucSlot {
 	/** name of the slot. A glib intern string. */
 	const gchar *name;
@@ -82,16 +87,12 @@ typedef struct _RaucSlot {
 	struct _RaucSlot *parent;
 	gchar *mount_point;
 	gchar *ext_mount_point;
+	RaucSlotStatus *status;
 } RaucSlot;
 
 typedef struct {
 } RaucSlotGroup;
 
-typedef struct {
-	gchar *status;
-	RaucChecksum checksum;
-} RaucSlotStatus;
-
 /**
  * Loads rauc system configuration from file.
  *
@@ -160,21 +161,22 @@ void free_slot_status(RaucSlotStatus *slotstatus);
 /**
  * Load slot status.
  *
- * This mounts the given slot, reads the status information from its status file
- * and unmounts the slot. If a problem occurs the created slot status consists
- * of default values. It should be freed with free_slot_status() when no longer
- * needed.
+ * Takes care to fill in slot status information into the designated component
+ * of the slot data structure: mount the given slot, read the status information
+ * from its status file and unmount the slot afterwards. If a problem occurs the
+ * stored slot status consists of default values. Do nothing if the status
+ * information have already been loaded before.
  *
  * @param dest_slot Slot to load status information for
- * @param slot_state return location for the slot information obtained
  */
-void load_slot_status(RaucSlot *dest_slot, RaucSlotStatus **slot_state);
+void load_slot_status(RaucSlot *dest_slot);
 
 /**
  * Save slot status.
  *
- * This mounts the given slot, writes the status information into its status
- * file and unmounts the slot afterwards.
+ * This mounts the given slot, transfers the status information from the
+ * designated component of the slot data structure into its status file and
+ * unmounts the slot afterwards.
  *
  * @param dest_slot Slot to write status information for
  * @param mfimage image that was just installed
diff --git a/src/config_file.c b/src/config_file.c
index 8c8d84f..8acfbf7 100644
--- a/src/config_file.c
+++ b/src/config_file.c
@@ -22,6 +22,7 @@ void r_free_slot(gpointer value) {
 	g_free(slot->type);
 	g_free(slot->bootname);
 	g_free(slot->mount_point);
+	g_clear_pointer(&slot->status, free_slot_status);
 	g_free(slot);
 }
 
@@ -455,15 +456,17 @@ free:
 	return res;
 }
 
-void load_slot_status(RaucSlot *dest_slot, RaucSlotStatus **slot_state) {
+void load_slot_status(RaucSlot *dest_slot) {
 	GError *ierror = NULL;
 	gboolean res = FALSE;
 	gchar *slotstatuspath = NULL;
 
 	g_return_if_fail(dest_slot);
-	g_return_if_fail(slot_state != NULL && *slot_state == NULL);
 
-	*slot_state = g_new0(RaucSlotStatus, 1);
+	if (dest_slot->status)
+		return;
+
+	dest_slot->status = g_new0(RaucSlotStatus, 1);
 
 	if (!is_slot_mountable(dest_slot))
 		return;
@@ -478,7 +481,7 @@ void load_slot_status(RaucSlot *dest_slot, RaucSlotStatus **slot_state) {
 
 	slotstatuspath = g_build_filename(dest_slot->mount_point, "slot.raucs", NULL);
 
-	res = read_slot_status(slotstatuspath, *slot_state, &ierror);
+	res = read_slot_status(slotstatuspath, dest_slot->status, &ierror);
 	if (!res) {
 		g_message("Failed to load status file %s: %s", slotstatuspath, ierror->message);
 		r_umount_slot(dest_slot, NULL);
@@ -501,7 +504,12 @@ gboolean save_slot_status(RaucSlot *dest_slot, RaucImage *mfimage, GError **erro
 	GError *ierror = NULL;
 	gboolean res = FALSE;
 	gchar *slotstatuspath = NULL;
-	RaucSlotStatus *slot_state = g_new0(RaucSlotStatus, 1);
+	RaucSlotStatus *slot_state = NULL;
+
+	g_return_val_if_fail(dest_slot, FALSE);
+	g_return_val_if_fail(dest_slot->status, FALSE);
+	g_return_val_if_fail(mfimage, FALSE);
+	g_return_val_if_fail(error == NULL || *error == NULL, FALSE);
 
 	if (!is_slot_mountable(dest_slot)) {
 		res = TRUE;
@@ -515,8 +523,11 @@ gboolean save_slot_status(RaucSlot *dest_slot, RaucImage *mfimage, GError **erro
 		goto free;
 	}
 
+	slot_state = dest_slot->status;
+	g_free(slot_state->status);
 	slot_state->status = g_strdup("ok");
 	slot_state->checksum.type = mfimage->checksum.type;
+	g_free(slot_state->checksum.digest);
 	slot_state->checksum.digest = g_strdup(mfimage->checksum.digest);
 
 	slotstatuspath = g_build_filename(dest_slot->mount_point, "slot.raucs", NULL);
@@ -538,7 +549,6 @@ gboolean save_slot_status(RaucSlot *dest_slot, RaucImage *mfimage, GError **erro
 
 free:
 	g_clear_pointer(&slotstatuspath, g_free);
-	g_clear_pointer(&slot_state, free_slot_status);
 
 	return res;
 }
diff --git a/src/install.c b/src/install.c
index 4bea909..903be90 100644
--- a/src/install.c
+++ b/src/install.c
@@ -868,7 +868,8 @@ static gboolean launch_and_wait_default_handler(RaucInstallArgs *args, gchar* bu
 
 		r_context_begin_step("check_slot", g_strdup_printf("Checking slot %s", dest_slot->name), 0);
 
-		load_slot_status(dest_slot, &slot_state);
+		load_slot_status(dest_slot);
+		slot_state = dest_slot->status;
 
 		/* In case we failed unmounting while reading status
 		 * file, abort here */
@@ -878,7 +879,6 @@ static gboolean launch_and_wait_default_handler(RaucInstallArgs *args, gchar* bu
 					"Slot '%s' still mounted", dest_slot->device);
 			r_context_end_step("check_slot", FALSE);
 
-			g_clear_pointer(&slot_state, free_slot_status);
 			goto out;
 		}
 
@@ -892,7 +892,6 @@ static gboolean launch_and_wait_default_handler(RaucInstallArgs *args, gchar* bu
 			r_context_begin_step("skip_image", "Copying image skipped", 0);
 			r_context_end_step("skip_image", TRUE);
 
-			g_clear_pointer(&slot_state, free_slot_status);
 			goto image_out;
 		}
 
@@ -900,7 +899,6 @@ static gboolean launch_and_wait_default_handler(RaucInstallArgs *args, gchar* bu
 		slot_state->status = g_strdup("update");
 
 		g_message("Slot needs to be updated with %s", mfimage->filename);
-		g_clear_pointer(&slot_state, free_slot_status);
 
 		r_context_end_step("check_slot", TRUE);
 
-- 
2.14.1

