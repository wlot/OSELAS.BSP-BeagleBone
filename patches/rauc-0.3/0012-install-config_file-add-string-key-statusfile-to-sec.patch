From 04719e88bcbba28e2d72b9588d43605177cb831a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ulrich=20=C3=96lmann?= <u.oelmann@pengutronix.de>
Date: Thu, 17 Aug 2017 11:51:26 +0200
Subject: [PATCH 12/44] install/config_file: add string key "statusfile" to
 section [system]
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Introduce this new key whose value specifies the file that is going to be used
to store RAUC's metadata including the current state of the slots.

Extend the test suite with tests for correctly parsing the specified path and
for setting the correct default value NULL if the key does not exist in the
[system] section of the config file at all.

Signed-off-by: Ulrich Ã–lmann <u.oelmann@pengutronix.de>
---
 docs/reference.rst    |  35 +++++++++++++----
 include/config_file.h |  18 +++++----
 src/config_file.c     | 104 +++++++++++++++++++++++++++++++++++++++++++++++++-
 test/config_file.c    |  31 +++++++++++++++
 4 files changed, 171 insertions(+), 17 deletions(-)

diff --git a/docs/reference.rst b/docs/reference.rst
index 91a975e..89267e2 100644
--- a/docs/reference.rst
+++ b/docs/reference.rst
@@ -73,6 +73,14 @@ Example configuration:
   system boots. If the value of this parameter is ``false`` the slot has to be
   activated manually in order to be booted, see section :ref:`mark-active`.
 
+.. _statusfile:
+
+``statusfile``
+  If this key exists, it points to a file where slot status information should
+  be stored (e.g. slot specific metadata, see :ref:`slot-status`).
+  This file should be located on a filesystem which is not overwritten during
+  updates.
+
 **[keyring] section**
 
 The ``keyring`` section refers to the trusted keyring used for signature
@@ -252,14 +260,25 @@ A valid manifest file must have the file extension ``.raucm``.
 ``hooks``
   List of per-slot hooks enabled for this image.
 
-
-Slot Status File
-----------------
-
-A slot status file is generated by RAUC after having updated a slot. If the
-slot is writeable for RAUC (because it contains a writable filesystem), it will
-place a small file named ``slot.raucs`` in its root directory, containing the
-sha256 of the installed image.
+.. _slot-status:
+
+Slot Status
+-----------
+
+There is some slot specific metadata that are of interest for RAUC, e.g. a hash
+value of the slot's content (SHA-256 per default) that is matched against its
+counterpart of an image inside a bundle to decide if an update of the slot has
+to be performed or can be skipped.
+These slot metadata can be persisted in one of two ways:
+either in a slot status file stored on each slot containing a writable
+filesystem or in a central status file that lives on a persistent filesystem
+untouched by updates.
+The former is RAUC's default whereas the latter mechanism is enabled by making
+use of the optional key :ref:`statusfile <statusfile>` in the ``system.conf``
+file.
+Both are formatted as INI-like key/value files where the slot information is
+grouped in a section named [slot] for the case of a per-slot file or in sections
+termed with the slot name (e.g. [slot.rootfs.1]) for the central status file:
 
 .. code-block:: cfg
 
diff --git a/include/config_file.h b/include/config_file.h
index 0d57f99..1e30b08 100644
--- a/include/config_file.h
+++ b/include/config_file.h
@@ -31,6 +31,7 @@ typedef struct {
 	gchar *mount_prefix;
 	gchar *grubenv_path;
 	gboolean activate_installed;
+	gchar *statusfile_path;
 	gchar *keyring_path;
 
 	gchar *autoinstall_path;
@@ -162,10 +163,11 @@ void free_slot_status(RaucSlotStatus *slotstatus);
  * Load slot status.
  *
  * Takes care to fill in slot status information into the designated component
- * of the slot data structure: mount the given slot, read the status information
- * from its status file and unmount the slot afterwards. If a problem occurs the
- * stored slot status consists of default values. Do nothing if the status
- * information have already been loaded before.
+ * of the slot data structure. If the user configured a global status file in
+ * the system.conf they are read from this file. Otherwise mount the given slot,
+ * read the status information from its local status file and unmount the slot
+ * afterwards. If a problem occurs the stored slot status consists of default
+ * values. Do nothing if the status information have already been loaded before.
  *
  * @param dest_slot Slot to load status information for
  */
@@ -174,9 +176,11 @@ void load_slot_status(RaucSlot *dest_slot);
 /**
  * Save slot status.
  *
- * This mounts the given slot, transfers the status information from the
- * designated component of the slot data structure into its status file and
- * unmounts the slot afterwards.
+ * This persists the status information from the designated component of the
+ * given slot data structure. If the user configured a global status file in the
+ * system.conf they are written to this file. Otherwise mount the given slot,
+ * transfer the status information to the local status file and unmount the slot
+ * afterwards.
  *
  * @param dest_slot Slot to write status information for
  * @param error return location for a GError, or NULL
diff --git a/src/config_file.c b/src/config_file.c
index 0be5291..5e92f58 100644
--- a/src/config_file.c
+++ b/src/config_file.c
@@ -1,8 +1,10 @@
 #include <config.h>
 
 #include <glib.h>
+#include <string.h>
 
 #include "config_file.h"
+#include "context.h"
 #include "manifest.h"
 #include "mount.h"
 #include "utils.h"
@@ -212,6 +214,9 @@ gboolean load_config(const gchar *filename, RaucConfig **config, GError **error)
 		c->system_variant = variant_data;
 	}
 
+	c->statusfile_path = resolve_path(filename,
+		g_key_file_get_string(key_file, "system", "statusfile", NULL));
+
 	/* parse [keyring] section */
 	c->keyring_path = resolve_path(filename,
 		g_key_file_get_string(key_file, "keyring", "path", NULL));
@@ -386,6 +391,7 @@ void free_config(RaucConfig *config) {
 	g_free(config->system_bootloader);
 	g_free(config->mount_prefix);
 	g_free(config->grubenv_path);
+	g_free(config->statusfile_path);
 	g_free(config->keyring_path);
 	g_free(config->autoinstall_path);
 	g_free(config->systeminfo_handler);
@@ -474,7 +480,7 @@ free:
 	return res;
 }
 
-void load_slot_status(RaucSlot *dest_slot) {
+static void load_slot_status_locally(RaucSlot *dest_slot) {
 	GError *ierror = NULL;
 	gboolean res = FALSE;
 	gchar *slotstatuspath = NULL;
@@ -517,8 +523,63 @@ free:
 	g_clear_error(&ierror);
 }
 
+static void load_slot_status_globally(void) {
+	GError *ierror = NULL;
+	GHashTable *slots = r_context()->config->slots;
+	GKeyFile *key_file = g_key_file_new();
+	gchar **groups, **group, *slotname;
+	GHashTableIter iter;
+	RaucSlot *slot;
 
-gboolean save_slot_status(RaucSlot *dest_slot, GError **error) {
+	g_return_if_fail(r_context()->config->statusfile_path);
+
+	g_key_file_load_from_file(key_file, r_context()->config->statusfile_path, G_KEY_FILE_NONE, &ierror);
+	if (ierror && !g_error_matches(ierror, G_FILE_ERROR, G_FILE_ERROR_NOENT))
+		g_message("load_slot_status_globally: %s.", ierror->message);
+	g_clear_error(&ierror);
+
+	/* Load all slot states included in the statusfile */
+	groups = g_key_file_get_groups(key_file, NULL);
+	for (group = groups; *group != NULL; group++) {
+		if (!g_str_has_prefix(*group, RAUC_SLOT_PREFIX "."))
+			continue;
+
+		slotname = *group + strlen(RAUC_SLOT_PREFIX ".");
+		slot = g_hash_table_lookup(slots, slotname);
+		if (!slot || slot->status)
+			continue;
+
+		slot->status = g_new0(RaucSlotStatus, 1);
+		g_debug("Load status for slot %s.", slot->name);
+		status_file_get_slot_status(key_file, *group, slot->status);
+	}
+	g_strfreev(groups);
+	g_clear_pointer(&key_file, g_key_file_free);
+
+	/* Set all other slots to the default status */
+	g_hash_table_iter_init(&iter, slots);
+	while (g_hash_table_iter_next(&iter, NULL, (gpointer) &slot)) {
+		if (slot->status)
+			continue;
+
+		g_debug("Set default status for slot %s.", slot->name);
+		slot->status = g_new0(RaucSlotStatus, 1);
+	}
+}
+
+void load_slot_status(RaucSlot *dest_slot) {
+	g_return_if_fail(dest_slot);
+
+	if (dest_slot->status)
+		return;
+
+	if (r_context()->config->statusfile_path)
+		load_slot_status_globally();
+	else
+		load_slot_status_locally(dest_slot);
+}
+
+static gboolean save_slot_status_locally(RaucSlot *dest_slot, GError **error) {
 	GError *ierror = NULL;
 	gboolean res = FALSE;
 	gchar *slotstatuspath = NULL;
@@ -562,6 +623,45 @@ free:
 	return res;
 }
 
+static gboolean save_slot_status_globally(RaucSlot *dest_slot, GError **error) {
+	GKeyFile *key_file = g_key_file_new();
+	GError *ierror = NULL;
+	gboolean res;
+	gchar *group;
+
+	g_return_val_if_fail(dest_slot, FALSE);
+	g_return_val_if_fail(dest_slot->status, FALSE);
+	g_return_val_if_fail(error == NULL || *error == NULL, FALSE);
+	g_return_val_if_fail(r_context()->config->statusfile_path, FALSE);
+
+	g_key_file_load_from_file(key_file, r_context()->config->statusfile_path, G_KEY_FILE_NONE, &ierror);
+	if (ierror && !g_error_matches(ierror, G_FILE_ERROR, G_FILE_ERROR_NOENT))
+		g_message("save_slot_status_globally: %s.", ierror->message);
+	g_clear_error(&ierror);
+
+	group = g_strdup_printf(RAUC_SLOT_PREFIX ".%s", dest_slot->name);
+	status_file_set_slot_status(key_file, group, dest_slot->status);
+	g_free(group);
+
+	res = g_key_file_save_to_file(key_file, r_context()->config->statusfile_path, &ierror);
+	if (!res)
+		g_propagate_error(error, ierror);
+
+	g_key_file_free(key_file);
+
+	return res;
+}
+
+gboolean save_slot_status(RaucSlot *dest_slot, GError **error) {
+	g_return_val_if_fail(dest_slot, FALSE);
+	g_return_val_if_fail(error == NULL || *error == NULL, FALSE);
+
+	if (r_context()->config->statusfile_path)
+		return save_slot_status_globally(dest_slot, error);
+	else
+		return save_slot_status_locally(dest_slot, error);
+}
+
 void free_slot_status(RaucSlotStatus *slotstatus) {
 	g_return_if_fail(slotstatus);
 
diff --git a/test/config_file.c b/test/config_file.c
index 399f8b6..b40d934 100644
--- a/test/config_file.c
+++ b/test/config_file.c
@@ -41,6 +41,7 @@ static void config_file_full_config(ConfigFileFixture *fixture,
 compatible=FooCorp Super BarBazzer\n\
 bootloader=barebox\n\
 mountprefix=/mnt/myrauc/\n\
+statusfile=/mnt/persistent-rw-fs/system.raucs\n\
 \n\
 [keyring]\n\
 path=/etc/rauc/keyring/\n\
@@ -91,6 +92,7 @@ ignore-checksum=true\n";
 	g_assert_cmpstr(config->system_bootloader, ==, "barebox");
 	g_assert_cmpstr(config->mount_prefix, ==, "/mnt/myrauc/");
 	g_assert_true(config->activate_installed);
+	g_assert_cmpstr(config->statusfile_path, ==, "/mnt/persistent-rw-fs/system.raucs");
 
 	g_assert_nonnull(config->slots);
 	slotlist = g_hash_table_get_keys(config->slots);
@@ -452,6 +454,32 @@ variant-name=";
 
 
 
+static void config_file_statusfile_missing(ConfigFileFixture *fixture,
+		gconstpointer user_data)
+{
+	RaucConfig *config;
+	GError *ierror = NULL;
+	gchar* pathname;
+
+	const gchar *cfg_file = "\
+[system]\n\
+compatible=FooCorp Super BarBazzer\n\
+bootloader=barebox\n\
+mountprefix=/mnt/myrauc/\n";
+
+
+	pathname = write_tmp_file(fixture->tmpdir, "valid_bootloader.conf", cfg_file, NULL);
+	g_assert_nonnull(pathname);
+
+	g_assert_true(load_config(pathname, &config, &ierror));
+	g_assert_null(ierror);
+	g_assert_nonnull(config);
+	g_assert_null(config->statusfile_path);
+
+	free_config(config);
+}
+
+
 static void config_file_test_read_slot_status(void)
 {
 	RaucSlotStatus *ss = g_new0(RaucSlotStatus, 1);
@@ -536,6 +564,9 @@ int main(int argc, char *argv[])
 	g_test_add_func("/config-file/read-slot-status", config_file_test_read_slot_status);
 	g_test_add_func("/config-file/write-read-slot-status", config_file_test_write_slot_status);
 	g_test_add_func("/config-file/system-serial", config_file_system_serial);
+	g_test_add("/config-file/statusfile-missing", ConfigFileFixture, NULL,
+		   config_file_fixture_set_up, config_file_statusfile_missing,
+		   config_file_fixture_tear_down);
 
 	return g_test_run ();
 }
-- 
2.14.1

