From 0625fd534a6db5ee99436ca8021ba0ecf12e3f5a Mon Sep 17 00:00:00 2001
From: Enrico Jorns <ejo@pengutronix.de>
Date: Thu, 5 Oct 2017 10:47:17 +0200
Subject: [PATCH 25/44] src/config_file: introduce `store_prefix` system config
 key

determine and use store path

Signed-off-by: Enrico Jorns <ejo@pengutronix.de>
---
 docs/reference.rst    | 12 ++++++++++++
 include/bundle.h      |  1 +
 include/config_file.h |  1 +
 src/bundle.c          | 15 +++++++++++++++
 src/config_file.c     |  4 ++++
 src/update_handler.c  | 12 ++++++++++--
 6 files changed, 43 insertions(+), 2 deletions(-)

diff --git a/docs/reference.rst b/docs/reference.rst
index 91a975e..165e6ba 100644
--- a/docs/reference.rst
+++ b/docs/reference.rst
@@ -82,6 +82,18 @@ verification.
   Path to the keyring file in PEM format. Either absolute or relative to the
   system.conf file.
 
+**[casync] section**
+
+The ``casync`` section contains casync-related settings.
+For more information about using casync support of RAUC, refer to `todo`_.
+
+``storepath``
+  Allows to set the path to use as chunk store path for casync to a fixed one.
+  This is useful if your chunk store is on a dedicated server and will be the
+  same pool for each update you perform.
+  By default, the chunk store path is derived from the location of the RAUC
+  bundle you install.
+
 **[autoinstall] section**
 
 The auto-install feature allows to configure a path that will be checked upon
diff --git a/include/bundle.h b/include/bundle.h
index d43296b..e34339f 100644
--- a/include/bundle.h
+++ b/include/bundle.h
@@ -14,6 +14,7 @@ typedef enum {
 typedef struct {
 	gchar *path;
 	gchar *origpath;
+	gchar *storepath;
 	gsize size;
 	gchar *mount_point;
 	STACK_OF(X509) *verified_chain;
diff --git a/include/config_file.h b/include/config_file.h
index d5c8512..f4876ce 100644
--- a/include/config_file.h
+++ b/include/config_file.h
@@ -29,6 +29,7 @@ typedef struct {
 	gchar *system_bootloader;
 	/* path prefix where rauc may create mount directories */
 	gchar *mount_prefix;
+	gchar *store_path;
 	gchar *grubenv_path;
 	gboolean activate_installed;
 	gchar *keyring_path;
diff --git a/src/bundle.c b/src/bundle.c
index ccf583a..f51d2f0 100644
--- a/src/bundle.c
+++ b/src/bundle.c
@@ -568,6 +568,21 @@ gboolean check_bundle(const gchar *bundlename, RaucBundle **bundle, gboolean ver
 		ibundle->path = g_strdup(bundlename);
 	}
 
+	/* Determine store path for casync, defaults to bundle */
+	if (r_context()->config->store_path) {
+		ibundle->storepath = r_context()->config->store_path;
+	} else {
+		gchar *strprfx;
+
+		if (ibundle->origpath)
+			strprfx = g_strndup(ibundle->origpath, strlen(ibundle->origpath) - 6);
+		else
+			strprfx = g_strndup(ibundle->path, strlen(ibundle->path) - 6);
+		ibundle->storepath = g_strconcat(strprfx, ".castr", NULL);
+
+		g_free(strprfx);
+	}
+
 	if (verify && !r_context()->config->keyring_path) {
 		g_set_error(error, R_BUNDLE_ERROR, R_BUNDLE_ERROR_KEYRING, "No keyring file provided");
 		res = FALSE;
diff --git a/src/config_file.c b/src/config_file.c
index 9aff27b..fe4c7c7 100644
--- a/src/config_file.c
+++ b/src/config_file.c
@@ -215,6 +215,9 @@ gboolean load_config(const gchar *filename, RaucConfig **config, GError **error)
 	c->keyring_path = resolve_path(filename,
 		g_key_file_get_string(key_file, "keyring", "path", NULL));
 
+	/* parse [casync] section */
+	c->store_path = g_key_file_get_string(key_file, "casync", "storepath", NULL);
+
 	/* parse [autoinstall] section */
 	c->autoinstall_path = resolve_path(filename,
 		g_key_file_get_string(key_file, "autoinstall", "path", NULL));
@@ -384,6 +387,7 @@ void free_config(RaucConfig *config) {
 	g_free(config->system_compatible);
 	g_free(config->system_bootloader);
 	g_free(config->mount_prefix);
+	g_free(config->store_path);
 	g_free(config->grubenv_path);
 	g_free(config->keyring_path);
 	g_free(config->autoinstall_path);
diff --git a/src/update_handler.c b/src/update_handler.c
index 85a7e17..c5e5ac8 100644
--- a/src/update_handler.c
+++ b/src/update_handler.c
@@ -108,7 +108,7 @@ out:
 	return res;
 }
 
-static gboolean casync_extract(RaucImage *image, gchar *dest, gchar *seed, GError **error)
+static gboolean casync_extract(RaucImage *image, gchar *dest, const gchar *seed, const gchar *store, GError **error)
 {
 	GSubprocess *sproc = NULL;
 	GError *ierror = NULL;
@@ -121,6 +121,10 @@ static gboolean casync_extract(RaucImage *image, gchar *dest, gchar *seed, GErro
 		g_ptr_array_add(args, g_strdup("--seed"));
 		g_ptr_array_add(args, g_strdup(seed));
 	}
+	if (store) {
+		g_ptr_array_add(args, g_strdup("--store"));
+		g_ptr_array_add(args, g_strdup(store));
+	}
 	g_ptr_array_add(args, g_strdup("--seed-output=no"));
 	g_ptr_array_add(args, g_strdup(image->filename));
 	g_ptr_array_add(args, g_strdup(dest));
@@ -176,6 +180,7 @@ static gboolean casync_extract_image(RaucImage *image, gchar *dest, GError **err
 	gboolean res = FALSE;
 	RaucSlot *seedslot = NULL;
 	gchar *seed = NULL;
+	gchar *store = NULL;
 
 	/* Prepare Seed */
 	seedslot = get_active_slot_class_member(image->slotclass);
@@ -187,9 +192,12 @@ static gboolean casync_extract_image(RaucImage *image, gchar *dest, GError **err
 	g_debug("Adding as casync blob seed: %s", seedslot->device);
 	seed = g_strdup(seedslot->device);
 
+	store = r_context()->install_info->mounted_bundle->storepath;
+	g_debug("Using store path: '%s'", store);
+
 extract:
 	/* Call casync to extract */
-	res = casync_extract(image, dest, seed, &ierror);
+	res = casync_extract(image, dest, seed, store, &ierror);
 	if (!res) {
 		g_propagate_error(error, ierror);
 		goto out;
-- 
2.14.1

