From 935346f18577e7d6f0c75df735200c1499425e17 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ulrich=20=C3=96lmann?= <u.oelmann@pengutronix.de>
Date: Wed, 6 Sep 2017 12:12:58 +0200
Subject: [PATCH 16/44] install/config_file: store activation information in
 status file
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Ulrich Ã–lmann <u.oelmann@pengutronix.de>
---
 Makefile.am           |  3 ++-
 docs/reference.rst    |  5 +++++
 docs/using.rst        |  3 +++
 include/config_file.h |  2 ++
 include/mark.h        |  2 ++
 src/config_file.c     | 25 +++++++++++++++++++++++++
 src/install.c         | 15 +++++++++++----
 src/mark.c            | 51 +++++++++++++++++++++++++++++++++++++++++++++++++--
 8 files changed, 99 insertions(+), 7 deletions(-)

diff --git a/Makefile.am b/Makefile.am
index 47c350d..811df2d 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -218,4 +218,5 @@ CLEANFILES = $(gdbus_installer_generated) \
 	     test/savedslot.raucs \
 	     test/grubenv.test \
 	     test/random.dat \
-	     test/test-temp.conf
+	     test/test-temp.conf \
+	     test/system.raucs
diff --git a/docs/reference.rst b/docs/reference.rst
index f07171e..865e8f6 100644
--- a/docs/reference.rst
+++ b/docs/reference.rst
@@ -314,6 +314,11 @@ section :ref:`Manifest <sec_ref_manifest>`.
 RAUC also stores the point in time of installing the image to the slot in
 ``installed.timestamp`` as well as the number of updates so far in
 ``installed.count``.
+Additionally RAUC tracks the point in time when a bootable slot is activated in
+``activated.timestamp`` and the number of activations in ``activated.count``,
+see section :ref:`mark-active`.
+Comparing both timestamps is useful to decide if an installed slot has ever been
+activated or if its activation is still pending.
 
 
 Command Line Tool
diff --git a/docs/using.rst b/docs/using.rst
index cc68c75..b9f2d46 100644
--- a/docs/using.rst
+++ b/docs/using.rst
@@ -156,6 +156,9 @@ do so by using its slot name which has the form ``<slot-class>.<idx>`` (e.g.
 after switching to a different slot by mistake, before having rebooted this can
 be remedied by choosing ``booted`` as the argument which is, by the way, the
 default if the optional argument has been omitted.
+The date and time of activation as well as the number of activations is part of
+the slot's metadata which is stored in the slot status file, see section
+:ref:`slot-status`.
 
 Customizing the Update
 ----------------------
diff --git a/include/config_file.h b/include/config_file.h
index 9d701a2..3074a55 100644
--- a/include/config_file.h
+++ b/include/config_file.h
@@ -69,6 +69,8 @@ typedef struct {
 	RaucChecksum checksum;
 	gchar *installed_timestamp;
 	guint32 installed_count;
+	gchar *activated_timestamp;
+	guint32 activated_count;
 } RaucSlotStatus;
 
 typedef struct _RaucSlot {
diff --git a/include/mark.h b/include/mark.h
index f9bb9ba..99e175d 100644
--- a/include/mark.h
+++ b/include/mark.h
@@ -2,6 +2,8 @@
 
 #include <glib.h>
 
+void mark_active(RaucSlot *slot, GError **error);
+
 gboolean mark_run(const gchar *state,
 		  const gchar *slot_identifier,
 		  gchar **slot_name,
diff --git a/src/config_file.c b/src/config_file.c
index 38fd47a..5f09bae 100644
--- a/src/config_file.c
+++ b/src/config_file.c
@@ -416,6 +416,7 @@ static void status_file_get_slot_status(GKeyFile *key_file, const gchar *group,
 	g_free(slotstatus->status);
 	g_clear_pointer(&slotstatus->checksum.digest, g_free);
 	g_free(slotstatus->installed_timestamp);
+	g_free(slotstatus->activated_timestamp);
 
 	slotstatus->bundle_compatible = g_key_file_get_string(key_file, group, "bundle.compatible", NULL);
 	slotstatus->bundle_version = g_key_file_get_string(key_file, group, "bundle.version", NULL);
@@ -444,6 +445,21 @@ static void status_file_get_slot_status(GKeyFile *key_file, const gchar *group,
 		count = 0;
 	}
 	slotstatus->installed_count = count;
+
+	slotstatus->activated_timestamp = g_key_file_get_string(key_file, group, "activated.timestamp", NULL);
+	count = g_key_file_get_uint64(key_file, group, "activated.count", &ierror);
+	if (g_error_matches(ierror, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_INVALID_VALUE)) {
+		g_message("Value of key \"activated.count\" in group [%s] "
+			"is no valid unsigned integer - setting to zero.", group);
+		count = 0;
+	}
+	g_clear_error(&ierror);
+	if (count > G_MAXUINT32) {
+		g_message("Value of key \"activated.count\" in group [%s] "
+			"is greater than G_MAXUINT32 - setting to zero.", group);
+		count = 0;
+	}
+	slotstatus->activated_count = count;
 }
 
 static void status_file_set_string_or_remove_key(GKeyFile *key_file, const gchar *group, const gchar *key, gchar *string) {
@@ -476,6 +492,14 @@ static void status_file_set_slot_status(GKeyFile *key_file, const gchar *group,
 		g_key_file_remove_key(key_file, group, "installed.count", NULL);
 	}
 
+	if (slotstatus->activated_timestamp) {
+		g_key_file_set_string(key_file, group, "activated.timestamp", slotstatus->activated_timestamp);
+		g_key_file_set_uint64(key_file, group, "activated.count", slotstatus->activated_count);
+	} else {
+		g_key_file_remove_key(key_file, group, "activated.timestamp", NULL);
+		g_key_file_remove_key(key_file, group, "activated.count", NULL);
+	}
+
 	return;
 }
 
@@ -718,5 +742,6 @@ void free_slot_status(RaucSlotStatus *slotstatus) {
 	g_free(slotstatus->status);
 	g_free(slotstatus->checksum.digest);
 	g_free(slotstatus->installed_timestamp);
+	g_free(slotstatus->activated_timestamp);
 	g_free(slotstatus);
 }
diff --git a/src/install.c b/src/install.c
index c690791..42c8c8b 100644
--- a/src/install.c
+++ b/src/install.c
@@ -19,6 +19,7 @@
 #include "context.h"
 #include "install.h"
 #include "manifest.h"
+#include "mark.h"
 #include "mount.h"
 #include "network.h"
 #include "service.h"
@@ -971,14 +972,20 @@ image_out:
 			if (dest_slot->parent || !dest_slot->bootname)
 				continue;
 
-			res = r_boot_set_primary(dest_slot, &ierror);
-
-			if (!res) {
+			mark_active(dest_slot, &ierror);
+			if (g_error_matches(ierror, R_INSTALL_ERROR, R_INSTALL_ERROR_MARK_BOOTABLE)) {
 				g_set_error(error, R_INSTALL_ERROR, R_INSTALL_ERROR_MARK_BOOTABLE,
-						"Failed marking slot %s bootable: %s", dest_slot->name, ierror->message);
+					"Failed marking slot %s bootable", dest_slot->name);
+				g_clear_error(&ierror);
+				goto out;
+			} else if (g_error_matches(ierror, R_INSTALL_ERROR, R_INSTALL_ERROR_FAILED)) {
+				g_set_error(error, R_INSTALL_ERROR, R_INSTALL_ERROR_FAILED,
+					"Marked slot %s bootable, but failed to write status file: %s",
+					dest_slot->name, ierror->message);
 				g_clear_error(&ierror);
 				goto out;
 			}
+			g_clear_error(&ierror);
 		}
 	} else {
 		g_message("Leaving target slot non-bootable as requested by activate_installed == false.");
diff --git a/src/mark.c b/src/mark.c
index 1fa1b23..42e3dfa 100644
--- a/src/mark.c
+++ b/src/mark.c
@@ -1,5 +1,6 @@
 #include "bootchooser.h"
 #include "context.h"
+#include "install.h"
 #include "mark.h"
 
 static RaucSlot* get_slot_by_identifier(const gchar *identifier, GError **error)
@@ -75,6 +76,41 @@ static RaucSlot* get_slot_by_identifier(const gchar *identifier, GError **error)
 	return slot;
 }
 
+void mark_active(RaucSlot *slot, GError **error)
+{
+	RaucSlotStatus *slot_state;
+	GError *ierror = NULL;
+	GDateTime *now;
+	gboolean res;
+
+	g_return_if_fail(slot);
+	g_return_if_fail(error == NULL || *error == NULL);
+
+	load_slot_status(slot);
+	slot_state = slot->status;
+
+	res = r_boot_set_primary(slot, &ierror);
+	if (!res) {
+		g_set_error(error, R_INSTALL_ERROR, R_INSTALL_ERROR_MARK_BOOTABLE,
+			"failed to activate slot %s: %s", slot->name, ierror->message);
+		g_error_free(ierror);
+		return;
+	}
+
+	g_free(slot_state->activated_timestamp);
+	now = g_date_time_new_now_utc();
+	slot_state->activated_timestamp = g_date_time_format(now, "%Y-%m-%dT%H:%M:%SZ");
+	slot_state->activated_count++;
+	g_date_time_unref(now);
+
+	res = save_slot_status(slot, &ierror);
+	if (!res) {
+		g_set_error(error, R_INSTALL_ERROR, R_INSTALL_ERROR_FAILED, "%s", ierror->message);
+		g_error_free(ierror);
+		return;
+	}
+}
+
 gboolean mark_run(const gchar *state,
 		  const gchar *slot_identifier,
 		  gchar **slot_name,
@@ -102,8 +138,19 @@ gboolean mark_run(const gchar *state,
 		res = r_boot_set_state(slot, FALSE, &ierror);
 		*message = res ? g_strdup_printf("marked slot %s as bad", slot->name) : g_strdup(ierror->message);
 	} else if (!g_strcmp0(state, "active")) {
-		res = r_boot_set_primary(slot, &ierror);
-		*message = res ? g_strdup_printf("activated slot %s", slot->name) : g_strdup(ierror->message);
+		mark_active(slot, &ierror);
+		if (g_error_matches(ierror, R_INSTALL_ERROR, R_INSTALL_ERROR_MARK_BOOTABLE)) {
+			res = FALSE;
+			*message = g_strdup(ierror->message);
+		} else if (g_error_matches(ierror, R_INSTALL_ERROR, R_INSTALL_ERROR_FAILED)) {
+			res = TRUE;
+			*message = g_strdup_printf("activated slot %s, but failed to write status file: %s",
+					slot->name, ierror->message);
+		} else {
+			res = TRUE;
+			*message = g_strdup_printf("activated slot %s", slot->name);
+		}
+		g_clear_error(&ierror);
 	} else {
 		res = FALSE;
 		*message = g_strdup_printf("unknown subcommand %s", state);
-- 
2.14.1

